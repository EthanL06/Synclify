import { type ExtMessage, MESSAGE_STATUS, MESSAGE_TYPE } from "~types/messaging"
import { SOCKET_EVENTS, SOCKET_URL } from "~types/socket"
import type { State } from "~types/state"
import { Storage } from "@plasmohq/storage"
import { VIDEO_EVENTS } from "~types/video"
import browser from "webextension-polyfill"
import { hasVideos, setState } from "~utils"
import { io } from "socket.io-client"
import { sendToBackground } from "@plasmohq/messaging"
import type { settingsSchema } from "~options"
import { z } from "zod"
import {
  BrowserClient,
  captureMessage,
  defaultStackParser,
  getDefaultIntegrations,
  makeFetchTransport,
  Scope
} from "@sentry/browser"

const integrations = getDefaultIntegrations({}).filter((defaultIntegration) => {
  return !["BrowserApiErrors", "Breadcrumbs", "GlobalHandlers"].includes(
    defaultIntegration.name
  )
})

const client = new BrowserClient({
  dsn: process.env.PLASMO_PUBLIC_SENTRY_DSN,
  tunnel: `${SOCKET_URL}/t`,
  transport: makeFetchTransport,
  stackParser: defaultStackParser,
  integrations: integrations
})

const scope = new Scope()
scope.setClient(client)

client.init()

const bootstrap = () => {
  let tabId: number
  let roomCode: string
  let state: State
  let video: HTMLVideoElement | null
  let syntheticEvent = false
  let settings: z.infer<typeof settingsSchema> | undefined

  const storage = new Storage({ area: "local", allCopied: true })
  const settingsStorage = new Storage({ area: "sync" })
  const socket = io(SOCKET_URL, {
    autoConnect: false,
    transports: ["websocket", "polling"]
  })

  const init = async (videoId: string) => {
    tabId = await sendToBackground({ name: "getTabId" })
    const savedState = await storage.get<State>("state")

    if (savedState === undefined) {
      const e = new Error("Stored state is undefined")
      scope.captureException(e)
      throw e
    }
    state = savedState

    settings = await settingsStorage.get("settings")
    roomCode = state[tabId].roomId
    if (roomCode) {
      if (socket.disconnected) socket.connect()
      return getVideo(videoId)
    }
  }
  // console.log("Synclify: loaded")

  const videoEventHandler = (event: Event) => {
    if (roomCode) {
      socket.emit(
        SOCKET_EVENTS.VIDEO_EVENT,
        roomCode,
        event.type,
        video?.volume,
        video?.currentTime
      )
    }
  }

  const checkVideoEvent = (event: Event) => {
    // if event comes from javascript code, stop videoEventHandler listener from firing
    if (syntheticEvent) {
      event.stopImmediatePropagation()
      // resetting flag
      syntheticEvent = false
    } else videoEventHandler(event)
  }

  const observer = new MutationObserver(() => {
    if (!video) getVideo()
  })

  const getVideo = (videoId?: string) => {
    video = videoId
      ? (document.querySelectorAll(
          `[data-synclify-id="${videoId}"]`
        )[0] as HTMLVideoElement)
      : document.getElementsByTagName("video")[0]
    captureMessage(
      "videoId is null, using first element returned by document.getElementsByTagName",
      "warning"
    )

    if (video !== null) {
      storage.set("state", setState(tabId, roomCode, state, true))
      for (const event of Object.values(VIDEO_EVENTS)) {
        video.addEventListener(event, checkVideoEvent)
      }
      observer.disconnect()
      sendToBackground({
        name: "showToast",
        body: { content: "Video detected" }
      })
      return { status: MESSAGE_STATUS.SUCCESS }
    }
    observer.observe(document, { subtree: true, childList: true })
    sendToBackground({
      name: "showToast",
      body: { error: true, content: "Video not found" }
    })
    captureMessage(`No video found in ${window.location.href}`, "info")
    return {
      status: MESSAGE_STATUS.ERROR,
      message: "Video not found"
    }
  }

  const joinRoom = () => {
    if (!roomCode) {
      const e = new Error("Invalid room code: " + roomCode)
      scope.captureException(e)
      throw e
    }
    socket.emit(SOCKET_EVENTS.JOIN, roomCode)
  }

  socket.on("reconnect", () => {
    joinRoom()
  })

  socket.on("connect", () => {
    joinRoom()
  })

  socket.on(SOCKET_EVENTS.FULL, (room) => {
    const e = new Error("Room is full: " + room)
    scope.captureException(e)
    throw e
  })

  socket.on("connect_error", () => {
    // revert to classic upgrade
    captureMessage("Socket connection error, allowing polling", "info")
    socket.io.opts.transports = ["polling", "websocket"]
  })

  socket.on(
    SOCKET_EVENTS.VIDEO_EVENT,
    (eventType: VIDEO_EVENTS, volumeValue: string, currentTime: string) => {
      if (video === null) {
        const e = new Error("Video is null in socket video event handler")
        scope.captureException(e)
        throw e
      }
      switch (eventType) {
        case VIDEO_EVENTS.PLAY:
          // flagging next event as generated by synclify
          syntheticEvent = true
          video.play().catch((e) => {
            console.error(e)

            if (e.name === "NotAllowedError") {
              sendToBackground({
                name: "showToast",
                body: {
                  error: true,
                  content:
                    "Video is not allowed to play! Interact with the page first."
                }
              })
            } else {
              scope.captureException(e)
            }
          })
          break
        case VIDEO_EVENTS.PAUSE:
          syntheticEvent = true
          video.pause()
          break
        case VIDEO_EVENTS.VOLUMECHANGE:
          if (!settings?.syncAudio) break
          syntheticEvent = true
          video.volume = Number.parseFloat(volumeValue)
          break
        case VIDEO_EVENTS.SEEKED: {
          const time = Number.parseInt(currentTime)
          syntheticEvent = true
          video.currentTime = time
          break
        }
      }
    }
  )

  browser.runtime.onMessage.addListener((request: ExtMessage) => {
    switch (request.type) {
      case MESSAGE_TYPE.INIT: {
        return init(request.videoId).then((res) => {
          return res
        })
      }
      case MESSAGE_TYPE.EXIT:
        for (const event of Object.values(VIDEO_EVENTS)) {
          video?.removeEventListener(event, checkVideoEvent)
        }
        socket.disconnect()
        observer.disconnect()
        video = null
        return Promise.resolve({
          status: MESSAGE_STATUS.SUCCESS
        })
      default:
        return
    }
  })
}

declare global {
  interface Window {
    synclify: boolean
  }
}

// check to avoid double loading
if (window.synclify !== true) {
  window.synclify = true

  if (hasVideos()) bootstrap()
}
